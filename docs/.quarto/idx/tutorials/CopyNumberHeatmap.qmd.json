{"title":"Tutorial: Copy Number Heatmaps","markdown":{"yaml":{"title":"Tutorial: Copy Number Heatmaps","warning":false,"message":false,"fig.width":7,"fig.height":5,"fig.align":"center"},"headingText":"Prepare setup","containsRefs":false,"markdown":"\n\nThere is a wealth of copy number data bundled within `GAMBLR.data` in the form of\nsegmented copy number profiles. \nThis tutorial will give you an overview of this data. It will also demonstrate\nhow to process segmented data into a set of bins\nsuch that the data can be represented as a matrix of CN values or log ratios. \n\n\nWe will first import the necessary packages:\n\n```{r load_packages}\n# Load packages\nlibrary(GAMBLR.open)\nsuppressMessages(library(dplyr))\n```\n\n## Metadata\n\nAs usual, we typically begin an analysis by loading the metadata and restricting\nthe rows to samples of interest based on any number of criteria. Here, we'll \nseparately look at the data from WGS (`genome` seq_type) and whole exome sequencing\n`capture` seq_type. \n\n```{r get_metadata}\n\ndlbcl_genome_meta = suppressMessages(get_gambl_metadata(seq_type_filter = \"genome\")) %>%\n                    filter(pathology==\"DLBCL\")\n\ndlbcl_exome_meta = suppressMessages(get_gambl_metadata(seq_type_filter = \"capture\")) %>%\n                    filter(pathology==\"DLBCL\")\n\n#remove any duplicate sample_id/seq_type combinations\ng_meta_clean = check_and_clean_metadata(dlbcl_genome_meta,\n                                      duplicate_action = \"keep_first\")\n#remove any duplicate sample_id/seq_type combinations\ne_meta_clean = check_and_clean_metadata(dlbcl_exome_meta,\n                                      duplicate_action = \"keep_first\")\n\nnrow(g_meta_clean)\nnrow(e_meta_clean)\n\n```\n\n\n\nThis shows that we have data from `r nrow(g_meta_clean)` genomes and `r nrow(e_meta_clean)` exomes just from DLBCLs. \n\n## Projections\n\nThe number of samples that have copy number results available isn't necessarily going to match this. Importantly, some studies\nare older and relied on the `grch37` (i.e. hg19) genome build whereas other studies used some flavour of `hg38`. In GAMBL,\nwe aim to *project* all results to both `grch37` and `hg38` so results are relatively comparable between studies. However,\nfor efficiency, GAMBLR.data doesn't have both projections for every data set (sorry!). Let's start by determining\nwhich of our samples in the metadata have data available for in case there are some results only available for one or the other\n*projection*.\n\n```{r get_seg_genome}\n\ng_segments_grch37 = get_cn_segments(these = g_meta_clean,\n                                    projection = 'grch37')\n\ng_segments_hg38 = get_cn_segments(these = g_meta_clean,\n                                    projection = 'hg38')\n\nlength(unique(g_segments_grch37$ID))\nlength(unique(g_segments_hg38$ID))\n```\n\nWe seem to only have copy number segments available from `r length(unique(g_segments_hg38$ID))` samples for hg38. \nFor grch37 we have data from `r length(unique(g_segments_grch37$ID))` samples. How about the exome data?\n\n\n\n```{r get_seg_exome}\n\ne_segments_grch37 = get_cn_segments(these = e_meta_clean,\n                                    projection = 'grch37')\n\ne_segments_hg38 = get_cn_segments(these = e_meta_clean,\n                                    projection = 'hg38')\n\nlength(unique(e_segments_grch37$ID))\nlength(unique(e_segments_hg38$ID))\n```\n\nOuch! We only provided copy number data from `genome` samples (so far). Let's proceed with the largest data set, \nwhich is the `genome` samples and grch37 projection.\n\n## From segments to bins\n\nSegmented copy number data can be difficult to work with for a variety of reasons. For any coordinate in the genome, it's unnecessarily\ncomplicated to determine the copy number of all samples. We simplify this by breaking the genome into a series of *bins* and determining\nthe copy number state of each bin across all samples. This yields a N by M matrix where N is the number of samples with copy number data\nand M is the number of bins. The `segmented_data_to_cn_matrix` function in `GAMBLR.utils` makes this easy. \nIn this example, we'll do this to our `r length(unique(g_segments_grch37$ID))` using 2500 bins. I've provided the metadata here\neven though it's not strictly necessary. This can be useful if you pass seg_data that contains rows from patients that you don't\nplan to analyze. Those rows will be removed before the slow process begins. \n\n```{r process_seg_data}\ntime_start = Sys.time();\ndlbcl_cn_binned = segmented_data_to_cn_matrix(\n                                  seg_data = g_segments_grch37,\n                                  strategy=\"auto_split\",\n                                  n_bins_split=2500,\n                                  these_samples_metadata = g_meta_clean)\ntime_end = Sys.time();\nelapsed = round(time_end - time_start)\nprint(elapsed)\n```\n\nThat took `r elapsed` to finish. As you might imagine, increasing the n_bins_split value will make this process\nslower but will increase the resolution of your analysis.\n\n```{r process_seg_data2}\n\nevery_seg = get_cn_segments(get_gambl_metadata())\nlength(unique(every_seg$ID))\ntime_start = Sys.time();\nall_cn_binned = segmented_data_to_cn_matrix(\n                                  seg_data = every_seg,\n                                  strategy=\"auto_split\",\n                                  n_bins_split=2500) #no metadata provided\ntime_end = Sys.time();\nelapsed = round(time_end - time_start)\nprint(elapsed)\n```\n\nAs you can see, the process took considerably longer this time because of the additional samples that weren't dropped. \n\n\nAs you might have guessed from the `strategy` parameter, there are other strategies for converting segmented data into a\ncopy number matrix that don't rely on equal-sized bins. The other options are 'custom_regions','cytobands' and 'GISTIC'. \nEach of these will be covered in another tutorial. You can find out more about these in the `segmented_data_to_cn_matrix` documentation.  \n\n## DLBCL Copy Number Heatmap\n\nLet's start with the most basic example. Using the copy number matrix we just created, we run `pretty_CN_heatmap`. As for\nmost other functions, you have to provide your metadata table via *these_samples_metadata*. You can often unambiguously refer\nto this parameter with the word *these*. \n\n```{r dlbcl_heatmap}\n\n# Generate a basic genome-wide CN heatmap\npretty_CN_heatmap(cn_state_matrix=dlbcl_cn_binned,\n                  these_samples_metadata = g_meta_clean,\n                  hide_annotations = \"chromosome\")\n\n```\n\n## Copy Number Heatmap for everything\n\nIn an earlier example, we generated a larger matrix from all the `grch37` copy number data in `GAMBLR.data`. There are\n`nrow(all_cn_binned)` samples in there. Let's see what that looks like in a heatmap. This time, we'll tell the function\nto scale the copy number values to the average ploidy of each sample using `scale_by_sample`.\n\n\n```{r all_heatmap}\n#| fig.height: 9\n\nall_genome_meta = get_gambl_metadata()\nall_genome_meta = check_and_clean_metadata(all_genome_meta,\n                                      duplicate_action = \"keep_first\")\n#drop any genomes that don't have copy number data\n\nall_genome_meta = dplyr::filter(all_genome_meta,sample_id %in% rownames(all_cn_binned))\n# Generate a genome-wide CN heatmap without clustering\n# Instead, we'll order samples based on pathology and lymphgen\npretty_CN_heatmap(cn_state_matrix=all_cn_binned,\n                  these_samples_metadata = all_genome_meta,\n                  scale_by_sample = TRUE,\n                  cluster_rows=F,\n                  metadataColumns = c(\"pathology\",\"lymphgen\"),\n                  sortByMetadataColumns = c(\"pathology\",\"lymphgen\"),\n                  bin_label_nudge = 1.08,\n                  labelTheseGenes = c(\"CDKN2A\",\"TP53\"),\n                  hide_annotations = \"chromosome\")\n\n```","srcMarkdownNoYaml":"\n\nThere is a wealth of copy number data bundled within `GAMBLR.data` in the form of\nsegmented copy number profiles. \nThis tutorial will give you an overview of this data. It will also demonstrate\nhow to process segmented data into a set of bins\nsuch that the data can be represented as a matrix of CN values or log ratios. \n\n## Prepare setup\n\nWe will first import the necessary packages:\n\n```{r load_packages}\n# Load packages\nlibrary(GAMBLR.open)\nsuppressMessages(library(dplyr))\n```\n\n## Metadata\n\nAs usual, we typically begin an analysis by loading the metadata and restricting\nthe rows to samples of interest based on any number of criteria. Here, we'll \nseparately look at the data from WGS (`genome` seq_type) and whole exome sequencing\n`capture` seq_type. \n\n```{r get_metadata}\n\ndlbcl_genome_meta = suppressMessages(get_gambl_metadata(seq_type_filter = \"genome\")) %>%\n                    filter(pathology==\"DLBCL\")\n\ndlbcl_exome_meta = suppressMessages(get_gambl_metadata(seq_type_filter = \"capture\")) %>%\n                    filter(pathology==\"DLBCL\")\n\n#remove any duplicate sample_id/seq_type combinations\ng_meta_clean = check_and_clean_metadata(dlbcl_genome_meta,\n                                      duplicate_action = \"keep_first\")\n#remove any duplicate sample_id/seq_type combinations\ne_meta_clean = check_and_clean_metadata(dlbcl_exome_meta,\n                                      duplicate_action = \"keep_first\")\n\nnrow(g_meta_clean)\nnrow(e_meta_clean)\n\n```\n\n\n\nThis shows that we have data from `r nrow(g_meta_clean)` genomes and `r nrow(e_meta_clean)` exomes just from DLBCLs. \n\n## Projections\n\nThe number of samples that have copy number results available isn't necessarily going to match this. Importantly, some studies\nare older and relied on the `grch37` (i.e. hg19) genome build whereas other studies used some flavour of `hg38`. In GAMBL,\nwe aim to *project* all results to both `grch37` and `hg38` so results are relatively comparable between studies. However,\nfor efficiency, GAMBLR.data doesn't have both projections for every data set (sorry!). Let's start by determining\nwhich of our samples in the metadata have data available for in case there are some results only available for one or the other\n*projection*.\n\n```{r get_seg_genome}\n\ng_segments_grch37 = get_cn_segments(these = g_meta_clean,\n                                    projection = 'grch37')\n\ng_segments_hg38 = get_cn_segments(these = g_meta_clean,\n                                    projection = 'hg38')\n\nlength(unique(g_segments_grch37$ID))\nlength(unique(g_segments_hg38$ID))\n```\n\nWe seem to only have copy number segments available from `r length(unique(g_segments_hg38$ID))` samples for hg38. \nFor grch37 we have data from `r length(unique(g_segments_grch37$ID))` samples. How about the exome data?\n\n\n\n```{r get_seg_exome}\n\ne_segments_grch37 = get_cn_segments(these = e_meta_clean,\n                                    projection = 'grch37')\n\ne_segments_hg38 = get_cn_segments(these = e_meta_clean,\n                                    projection = 'hg38')\n\nlength(unique(e_segments_grch37$ID))\nlength(unique(e_segments_hg38$ID))\n```\n\nOuch! We only provided copy number data from `genome` samples (so far). Let's proceed with the largest data set, \nwhich is the `genome` samples and grch37 projection.\n\n## From segments to bins\n\nSegmented copy number data can be difficult to work with for a variety of reasons. For any coordinate in the genome, it's unnecessarily\ncomplicated to determine the copy number of all samples. We simplify this by breaking the genome into a series of *bins* and determining\nthe copy number state of each bin across all samples. This yields a N by M matrix where N is the number of samples with copy number data\nand M is the number of bins. The `segmented_data_to_cn_matrix` function in `GAMBLR.utils` makes this easy. \nIn this example, we'll do this to our `r length(unique(g_segments_grch37$ID))` using 2500 bins. I've provided the metadata here\neven though it's not strictly necessary. This can be useful if you pass seg_data that contains rows from patients that you don't\nplan to analyze. Those rows will be removed before the slow process begins. \n\n```{r process_seg_data}\ntime_start = Sys.time();\ndlbcl_cn_binned = segmented_data_to_cn_matrix(\n                                  seg_data = g_segments_grch37,\n                                  strategy=\"auto_split\",\n                                  n_bins_split=2500,\n                                  these_samples_metadata = g_meta_clean)\ntime_end = Sys.time();\nelapsed = round(time_end - time_start)\nprint(elapsed)\n```\n\nThat took `r elapsed` to finish. As you might imagine, increasing the n_bins_split value will make this process\nslower but will increase the resolution of your analysis.\n\n```{r process_seg_data2}\n\nevery_seg = get_cn_segments(get_gambl_metadata())\nlength(unique(every_seg$ID))\ntime_start = Sys.time();\nall_cn_binned = segmented_data_to_cn_matrix(\n                                  seg_data = every_seg,\n                                  strategy=\"auto_split\",\n                                  n_bins_split=2500) #no metadata provided\ntime_end = Sys.time();\nelapsed = round(time_end - time_start)\nprint(elapsed)\n```\n\nAs you can see, the process took considerably longer this time because of the additional samples that weren't dropped. \n\n\nAs you might have guessed from the `strategy` parameter, there are other strategies for converting segmented data into a\ncopy number matrix that don't rely on equal-sized bins. The other options are 'custom_regions','cytobands' and 'GISTIC'. \nEach of these will be covered in another tutorial. You can find out more about these in the `segmented_data_to_cn_matrix` documentation.  \n\n## DLBCL Copy Number Heatmap\n\nLet's start with the most basic example. Using the copy number matrix we just created, we run `pretty_CN_heatmap`. As for\nmost other functions, you have to provide your metadata table via *these_samples_metadata*. You can often unambiguously refer\nto this parameter with the word *these*. \n\n```{r dlbcl_heatmap}\n\n# Generate a basic genome-wide CN heatmap\npretty_CN_heatmap(cn_state_matrix=dlbcl_cn_binned,\n                  these_samples_metadata = g_meta_clean,\n                  hide_annotations = \"chromosome\")\n\n```\n\n## Copy Number Heatmap for everything\n\nIn an earlier example, we generated a larger matrix from all the `grch37` copy number data in `GAMBLR.data`. There are\n`nrow(all_cn_binned)` samples in there. Let's see what that looks like in a heatmap. This time, we'll tell the function\nto scale the copy number values to the average ploidy of each sample using `scale_by_sample`.\n\n\n```{r all_heatmap}\n#| fig.height: 9\n\nall_genome_meta = get_gambl_metadata()\nall_genome_meta = check_and_clean_metadata(all_genome_meta,\n                                      duplicate_action = \"keep_first\")\n#drop any genomes that don't have copy number data\n\nall_genome_meta = dplyr::filter(all_genome_meta,sample_id %in% rownames(all_cn_binned))\n# Generate a genome-wide CN heatmap without clustering\n# Instead, we'll order samples based on pathology and lymphgen\npretty_CN_heatmap(cn_state_matrix=all_cn_binned,\n                  these_samples_metadata = all_genome_meta,\n                  scale_by_sample = TRUE,\n                  cluster_rows=F,\n                  metadataColumns = c(\"pathology\",\"lymphgen\"),\n                  sortByMetadataColumns = c(\"pathology\",\"lymphgen\"),\n                  bin_label_nudge = 1.08,\n                  labelTheseGenes = c(\"CDKN2A\",\"TP53\"),\n                  hide_annotations = \"chromosome\")\n\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"ayu","toc":true,"css":["styles.css"],"output-file":"CopyNumberHeatmap.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","code-annotations":"hover","theme":{"light":["flatly","../theme-light.scss"],"dark":["darkly","../theme-dark.scss"]},"title":"Tutorial: Copy Number Heatmaps","message":false,"fig.width":7,"fig.height":5,"fig.align":"center"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}